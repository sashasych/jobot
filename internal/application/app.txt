package application

import (
	"context"
	"errors"
	"fmt"
	"jobot/internel/transport/rest"
	"jobot/pkg/database"
	"jobot/pkg/logger"
	"net/http"
	"sync"
	"time"

	"github.com/kelseyhightower/envconfig"
	"go.uber.org/zap"
)

const (
	shutDownTimeout = 10 * time.Second
)

type Application struct {
	config     *Config
	logger     *logger.Logger
	serverHTTP *http.Server
	db         *database.PostgresPool
}

// NewApplication создает новое приложение с загруженной конфигурацией
func NewApplication() (*Application, error) {
	// Загружаем конфигурацию из переменных окружения
	cfg := &Config{}
	if err := envconfig.Process("", cfg); err != nil {
		return nil, fmt.Errorf("failed to load configuration from env: %w", err)
	}

	// Создаем логгер
	log, err := logger.NewLogger(cfg.App.GetLogLevel())
	if err != nil {
		return nil, fmt.Errorf("failed to create logger: %w", err)
	}

	// Создаем пул соединений с БД
	db, err := database.NewPostgresPool(context.Background(), cfg.Database)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	return &Application{
		config: cfg,
		logger: log,
		db:     db,
	}, nil
}

// Initialize инициализирует приложение (создает контроллеры, сервисы и т.д.)
func (app *Application) Initialize(ctx context.Context) error {
	app.logger.Info("Initializing application",
		zap.String("app_name", app.config.App.Name),
		zap.String("version", app.config.App.Version),
		zap.String("environment", app.config.App.Environment),
		zap.Bool("debug", app.config.App.Debug),
	)

	// Создаем репозитории
	userRepo := user.NewUserRepository(app.db)

	// Создаем сервисы
	userService := service.NewUserService(userRepo, app.logger)

	// Создаем контроллеры
	userController := controllers.NewUserController(userService, app.logger)

	// Создаем HTTP сервер
	cfgHTTP := &rest.ConfigHTTPServer{
		Port:         app.config.HTTP.Port,
		Host:         app.config.HTTP.Host,
		ReadTimeout:  app.config.HTTP.ReadTimeout,
		WriteTimeout: app.config.HTTP.WriteTimeout,
		IdleTimeout:  app.config.HTTP.IdleTimeout,
	}

	app.serverHTTP = rest.CreateHTTPServerWithChi(ctx, cfgHTTP, userController)

	app.logger.Info("Application initialized successfully")
	return nil
}

// Start запускает приложение
func (app *Application) Start(ctx context.Context, wg *sync.WaitGroup, cancel context.CancelFunc) {
	app.logger.Info("Starting application",
		zap.String("http_address", app.config.HTTP.GetAddress()),
	)

	wg.Add(1)
	go app.startHTTPServer(wg, cancel)

	wg.Add(1)
	go app.gracefulStop(ctx, wg)
}

// startHTTPServer запускает HTTP сервер
func (app *Application) startHTTPServer(wg *sync.WaitGroup, cancel context.CancelFunc) {
	defer wg.Done()

	app.logger.Info("HTTP server starting",
		zap.String("address", app.config.HTTP.GetAddress()),
	)

	err := app.serverHTTP.ListenAndServe()
	if err != nil && !errors.Is(err, http.ErrServerClosed) {
		app.logger.Error("HTTP server failed to start",
			zap.Error(err),
		)
		cancel()
	}
}

// gracefulStop корректно останавливает приложение
func (app *Application) gracefulStop(ctx context.Context, wg *sync.WaitGroup) {
	defer wg.Done()

	<-ctx.Done()

	app.logger.Info("Application shutting down")

	wgShutDown := sync.WaitGroup{}
	wgShutDown.Add(1)

	go func() {
		defer wgShutDown.Done()

		ctxShutDown, cancelShutDown := context.WithTimeout(context.Background(), shutDownTimeout)
		defer cancelShutDown()

		app.logger.Info("Shutting down HTTP server")
		if err := app.serverHTTP.Shutdown(ctxShutDown); err != nil {
			app.logger.Error("HTTP server shutdown failed",
				zap.Error(err),
			)
		}

		app.logger.Info("Closing database connections")
		if app.db != nil {
			app.db.Close()
		}
	}()

	wgShutDown.Wait()
	app.logger.Info("Application stopped")
}

// GetConfig возвращает конфигурацию приложения
func (app *Application) GetConfig() *Config {
	return app.config
}

// GetLogger возвращает логгер приложения
func (app *Application) GetLogger() *logger.Logger {
	return app.logger
}

// GetDB возвращает пул соединений с БД
func (app *Application) GetDB() *database.Pool {
	return app.db
}
